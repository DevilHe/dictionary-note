#### 面试题集合

##### 第 1 题：['1', '2', '3'].map(parseInt) what & why ?

['1', '2', '3'].map(parseInt)，实际执行的代码是

```
['1', '2', '3'].map((item, index) => {
	return parseInt(item, index)
})

// ['1', '2', '3'].map(parseInt) = [parseInt('1', 0), parseInt('2', 1), parseInt('3', 2)]
```

即返回的值分别为：

```
parseInt('1', 0) // 1
parseInt('2', 1) // NaN
parseInt('3', 2) // NaN, 3 不是二进制
```

所以结果为

```
[1, NaN, NaN]
```

parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。

```
const intValue = parseInt(string[, radix]);
```

string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。

radix 一个介于 2 和 36 之间的整数(数学系统的基础)，表示上述字符串的基数。默认为 10。
返回值 返回一个整数或 NaN

在 radix 为 undefined，或者 radix 为 0 或者没有指定的情况下，JavaScript 作如下处理：
如果字符串 string 以"0x"或者"0X"开头, 则基数是 16 (16 进制).
如果字符串 string 以"0"开头, 基数是 8（八进制）或者 10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用 10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出 radix 参数的值。
如果字符串 string 以其它任何值开头，则基数是 10 (十进制)。

map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。

```
var new_array = arr.map(function callback(currentValue[,index[, array]]) {
 // Return element for new_array
 }[, thisArg])
```

可以看到 callback 回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。
currentValue 是 callback 数组中正在处理的当前元素。
index 可选, 是 callback 数组中正在处理的当前元素的索引。
array 可选, 是 callback map 方法被调用的数组。
另外还有 thisArg 可选, 执行 callback 函数时使用的 this 值。

如果实际上想要循环访问字符串数组, 该怎么办？ map()然后把它换成数字？使用编号!

```
['1', '2', '3'].map(Number)
// [1, 2, 3]
```

##### 第 2 题：要求实现函数体 var foo = function(...args) {}，使

```
var f1 = foo(1,2,3); f1.getValue(); // 6 输出是参数的和
var f2 = foo(1)(2,3); f2.getValue(); // 6
var f3 = foo(1)(2)(3)(4); f3.getValue(); // 10
```

（闭包 JS 基础）

```
// 方法1
var foo = function(...args) {
  // 要求实现函数体
  console.log('args', args, ...args)
  const target = (...arg1s) => foo(...[...args, ...arg1s]);
  console.log('target', target)
  target.getValue = () => args.reduce((p, n) => p+ n, 0);
  return target;
}

// 方法2
function foo(...args) {
  const sum = args.reduce((acc, v) => acc + v, 0);
  const hof = function (...args) {
    return foo(sum, ...args);
  };
  hof.getValue = () => sum;
  return hof;
}

var f1 = foo(1,2,3);
console.log(f1.getValue()) // 6

```

##### 第 3 题：对于扩展运算符，下面代码的执行结果是什么？并解释原因

```
let ydObject = { ...null, ...undefined };
console.log('ydObject', ydObject);
let ydArray = [ ...null, ...undefined ];
console.log('ydArray', ydObject);

```

###### 答案

```
{} 抛出异常

```

###### 解析

对象会忽略 null 和 undefined，数组会抛异常。这是 ECMA 的规范定义，所以在使用扩展运算符时要多加注意。补充一点，null 只能等于 undefined，其余谁也不等。

##### 第 4 题：请用算法实现，从给定的无序、不重复的数组 data 中，取出 n 个数，使其相加和为 sum，并给出算法的时间/空间复杂度。（找到其中一个解即可）

###### 答案

```
/**
 * 解题思路：从array中取出n个数全排列，在取的同时判断是否符合条件，为了不影响后续排列，每次递归完成，将当前的数组添加到正在排序的array中
 * 时间复杂度O(n)
 * 空间复杂度O(n)
 * @param {array} array 需要判断的数组
 * @param {number} n 取出n个数
 * @param {number} sum 和为sum的值
 * @param {array} temp 输出和为sum的数组
 * /

 function getAllCombin(array, n, sum, temp) {
  if(temp.length === n) {
    if(temp.reduce((t, c) => t + c) === sum) {
      return temp;
    }
    return false;
  }
  for(let i=0;i<array.length;i++) {
    const current = array.shift();
    temp.push(current);
    const result = getAllCombin(array, n, sum, temp);
    if(result) {
      return result;
    }
    temp.pop();
    array.push(current);
  }
}
const arr = [1, 5, 6, 2, 4, 3];
console.log('getAllCombin' ,getAllCombin(arr, 3, 10, []))
// [1, 5, 4]

```

##### 第 5 题：写出执行结果，Math.min()和 Math.max()无参数返回值

```
var min = Math.min(); // Infinity
var max = Math.max(); // -Infinity
console.log(min < max)

```

###### 答案

```
false
```

###### 解析

MDN 相关文档是这样解释的：
Math.min 的参数是 0 个或多个，如果多个参数很容易理解，返回参数中最小的。如果没有参数，则返回 Infinity，无穷大。
而 Math.max()没有传递参数时返回的是-Infinity，所以输出 false。
