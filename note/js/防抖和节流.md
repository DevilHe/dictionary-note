#### 防抖和节流

##### 1.防抖

原理：在事件被触发 n 秒后再执行回调，如果在这 n 秒内又被触发，则重新计时。
适用场景：
按钮提交场景：防止多次提交按钮，只执行最后提交的一次
搜索框联想场景：防止联想发送请求，只发送最后一次输入

1.1 简易版实现

```
function debounce(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    clearTimeout(timeout)
    timeout = setTimeout(function(){
      func.apply(context, args)
    }, wait);
  }
}

```

1.2 立即执行版实现
有时希望立刻执行函数，然后等到停止触发 n 秒后，才可以重新触发执行。

```
function debounce(func, wait, immediate) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait)
      if (callNow) func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args)
      }, wait);
    }
  }
}

```

1.3 返回值版实现
func 函数可能会有返回值，所以需要返回函数结果，但是当 immediate 为 false 的时候，因为使用了 setTimeout ，我们将 func.apply(context, args) 的返回值赋给变量，最后再 return 的时候，值将会一直是 undefined，所以只在 immediate 为 true 的时候返回函数的执行结果。

```
function debounce(func, wait, immediate) {
  let timeout, result;
  return function () {
    const context = this;
    const args = arguments;
    // console.log('this', context)
    // console.log('arguments', args)
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait)
      if (callNow) result = func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        // console.log('func1', func)
        func.apply(context, args)
        // console.log('func', func)
      }, wait);
    }
		console.log('result', result)
    return result;
  }
}

var btn = document.getElementById('fangdou');
var btn2 = document.getElementById('fangdou2');
function getUserAction(e) {
  // console.log(e);
  let date = +new Date();
  console.log('执行查询操作', date);
  // return date; //debounce(getUserAction, 1000, true)
};

var count=0;
function getUserAction2(){
  count ++;
  console.log('count', count)
	return count;
}

const debounceAjax = debounce(getUserAction, 1000)
// const debounceAjax2 = debounce(getUserAction2, 1000) // 无返回值
const debounceAjax2 = debounce(getUserAction2, 1000, true) // 有返回值
btn.addEventListener('keyup', debounceAjax)
btn2.addEventListener('click', debounceAjax2)

// html代码
<div>
  <input type="input" name="fangdou" id="fangdou" value="" />
  <button id="fangdou2">防抖</button>
</div>

```

##### 2.节流

原理：规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。
适用场景
拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动
缩放场景：监控浏览器 resize

2.1 使用时间戳实现
使用时间戳，当触发事件的时候，我们取出当前的时间戳，然后减去之前的时间戳(最一开始值设为 0 )，如果大于设置的时间周期，就执行函数，然后更新时间戳为当前的时间戳，如果小于，就不执行。

```
function throttle(func, wait) {
  let context, args;
  let previous = 0;

  return function () {
    let now = +new Date();
    context = this;
    args = arguments;
    if (now - previous > wait) {
      func.apply(context, args);
      previous = now;
    }
  }
}

```

2.2 使用定时器实现
当触发事件的时候，我们设置一个定时器，再触发事件的时候，如果定时器存在，就不执行，直到定时器执行，然后执行函数，清空定时器，这样就可以设置下个定时器。

```
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args)
      }, wait)
    }
  }
}

var count=0;
function jieliu(){
  count ++;
  console.log('节流', count)
}
const jieliuAjax = throttle(jieliu, 2000)

var scrollDiv = document.getElementById('scrollDiv');
scrollDiv.addEventListener('scroll', jieliuAjax)
// window.addEventListener('scroll', jieliuAjax)
window.addEventListener('resize', jieliuAjax)

// html代码
<div id="scrollDiv" style="width: 200px;height: 200px;overflow-y: auto;">
  <div>1</div>
  <div>2</div>
  <div>3</div>
  <div>4</div>
  <div>5</div>
  <div>6</div>
  <div>7</div>
  <div>8</div>
  <div>9</div>
  <div>10</div>
  <div>11</div>
  <div>12</div>
  <div>13</div>
  <div>14</div>
  <div>15</div>
  <div>16</div>
  <div>17</div>
  <div>18</div>
  <div>19</div>
  <div>20</div>
</div>

```
